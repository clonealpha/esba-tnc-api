package main

import (
	"fmt"
	"os"
	"path/filepath"
	"strings"
)

// GenerateConverters는 변환 함수를 생성합니다.
func GenerateConverters(binapiTypes map[string]*BinapiType, config *Config, outputPath string) error {
	// 출력 디렉토리 생성
	outputDir := filepath.Dir(outputPath)
	if err := os.MkdirAll(outputDir, 0755); err != nil {
		return fmt.Errorf("출력 디렉토리 생성 실패: %w", err)
	}

	// 파일 생성
	f, err := os.Create(outputPath)
	if err != nil {
		return fmt.Errorf("파일 생성 실패: %w", err)
	}
	defer f.Close()

	// 헤더 작성
	writeConverterHeader(f)

	// 각 리소스에 대해 변환 함수 생성
	for _, resource := range config.Resources {
		if resource.BinapiMessage == "" {
			continue
		}

		binapiType, ok := binapiTypes[resource.BinapiMessage]
		if !ok {
			continue
		}

		if err := writeConverterFunction(f, binapiType, &resource); err != nil {
			return fmt.Errorf("변환 함수 생성 실패 (%s): %w", resource.Name, err)
		}
	}

	fmt.Fprintf(f, "\n// 이 파일은 자동 생성되었습니다.\n")
	fmt.Fprintf(f, "// 수정하려면 tools/proto-generator를 사용하세요.\n")

	return nil
}

// writeConverterHeader는 변환 함수 파일 헤더를 작성합니다.
func writeConverterHeader(f *os.File) {
	fmt.Fprintf(f, "package handler\n\n")
	fmt.Fprintf(f, "// Code generated by proto-generator. DO NOT EDIT.\n\n")
	fmt.Fprintf(f, "import (\n")
	fmt.Fprintf(f, "\t\"fmt\"\n\n")
	fmt.Fprintf(f, "\t\"github.com/clonealpha/esba-tnc-api/proto\"\n")
	fmt.Fprintf(f, "\t// binapi imports will be added automatically\n")
	fmt.Fprintf(f, ")\n\n")
}

// writeConverterFunction는 변환 함수를 작성합니다.
func writeConverterFunction(f *os.File, binapiType *BinapiType, resource *ResourceConfig) error {
	funcName := fmt.Sprintf("convert%s", strings.Title(resource.Name))
	
	// binapi 패키지 alias
	binapiPkg := getBinapiPackage(binapiType.Package)
	binapiTypeName := fmt.Sprintf("%s.%s", binapiPkg, binapiType.Name)

	fmt.Fprintf(f, "// %s는 %s 데이터를 protobuf로 변환합니다.\n", funcName, resource.Name)
	fmt.Fprintf(f, "func %s(data interface{}) (interface{}, error) {\n", funcName)
	
	// 타입 체크
	if resource.ListMessage != "" {
		// 리스트 타입
		fmt.Fprintf(f, "\titems, ok := data.([]%s)\n", binapiTypeName)
		fmt.Fprintf(f, "\tif !ok {\n")
		fmt.Fprintf(f, "\t\treturn nil, fmt.Errorf(\"invalid data type for %s\")\n", resource.Name)
		fmt.Fprintf(f, "\t}\n\n")
		
		// 리스트 생성
		protoListField := toPlural(resource.Name)
		fmt.Fprintf(f, "\tpbItems := make([]*proto.%s, 0, len(items))\n", resource.ProtoMessage)
		fmt.Fprintf(f, "\tfor _, item := range items {\n")
		fmt.Fprintf(f, "\t\tpbItem := &proto.%s{\n", resource.ProtoMessage)
		
		// 필드 변환
		for _, field := range binapiType.Fields {
			protoFieldName := toProtoFieldName(field.Name)
			conversion := getFieldConversion(field, resource)
			fmt.Fprintf(f, "\t\t\t%s: %s,\n", strings.Title(protoFieldName), conversion)
		}
		
		fmt.Fprintf(f, "\t\t}\n")
		fmt.Fprintf(f, "\t\tpbItems = append(pbItems, pbItem)\n")
		fmt.Fprintf(f, "\t}\n\n")
		
		fmt.Fprintf(f, "\treturn &proto.%s{\n", resource.ListMessage)
		fmt.Fprintf(f, "\t\t%s: pbItems,\n", strings.Title(protoListField))
		fmt.Fprintf(f, "\t}, nil\n")
	} else {
		// 단일 타입
		fmt.Fprintf(f, "\titem, ok := data.(*%s)\n", binapiTypeName)
		fmt.Fprintf(f, "\tif !ok {\n")
		fmt.Fprintf(f, "\t\treturn nil, fmt.Errorf(\"invalid data type for %s\")\n", resource.Name)
		fmt.Fprintf(f, "\t}\n\n")
		
		fmt.Fprintf(f, "\treturn &proto.%s{\n", resource.ProtoMessage)
		
		// 필드 변환
		for _, field := range binapiType.Fields {
			protoFieldName := toProtoFieldName(field.Name)
			conversion := getFieldConversion(field, resource)
			fmt.Fprintf(f, "\t\t%s: %s,\n", strings.Title(protoFieldName), conversion)
		}
		
		fmt.Fprintf(f, "\t}, nil\n")
	}
	
	fmt.Fprintf(f, "}\n\n")
	return nil
}

// getFieldConversion는 필드 변환 코드를 생성합니다.
func getFieldConversion(field BinapiField, resource *ResourceConfig) string {
	fieldName := field.Name

	// 설정에 변환 함수가 있으면 사용
	if resource.Fields != nil {
		for _, mapping := range resource.Fields {
			if mapping.BinapiField == field.Name && mapping.Converter != "" {
				return strings.ReplaceAll(mapping.Converter, "{{field}}", "item."+fieldName)
			}
		}
	}

	// 타입에 따른 기본 변환
	goType := field.Type
	
	// 기본 타입
	if goType == "uint32" || goType == "uint16" || goType == "uint8" {
		return fmt.Sprintf("uint32(item.%s)", fieldName)
	}
	if goType == "int32" || goType == "int16" || goType == "int8" {
		return fmt.Sprintf("int32(item.%s)", fieldName)
	}
	if goType == "bool" {
		return fmt.Sprintf("item.%s", fieldName)
	}
	if goType == "string" {
		return fmt.Sprintf("item.%s", fieldName)
	}

	// 특수 타입
	if strings.Contains(goType, "InterfaceIndex") {
		return fmt.Sprintf("uint32(item.%s)", fieldName)
	}
	if strings.Contains(goType, "IfStatusFlags") {
		return fmt.Sprintf("uint32(item.%s)", fieldName)
	}
	if strings.Contains(goType, "MacAddress") {
		return fmt.Sprintf("item.%s.String()", fieldName)
	}
	if strings.Contains(goType, "Address") {
		return fmt.Sprintf("item.%s.String()", fieldName)
	}

	// 기본값: 직접 할당
	return fmt.Sprintf("item.%s", fieldName)
}

// getBinapiPackage는 binapi 패키지의 import alias를 반환합니다.
func getBinapiPackage(pkgName string) string {
	// 패키지 이름을 import alias로 변환
	aliasMap := map[string]string{
		"interface":    "interfaces",
		"ip_neighbor":  "ip_neighbor",
		"ip":           "ip",
		"acl":          "acl",
		"memif":        "memif",
		"sr":           "sr",
		"vpe":          "vpe",
		"vxlan":        "vxlan",
		"l2":           "l2",
	}

	if alias, ok := aliasMap[pkgName]; ok {
		return alias
	}
	return pkgName
}

